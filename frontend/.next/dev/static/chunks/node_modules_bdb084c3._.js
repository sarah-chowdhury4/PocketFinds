(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@reduxjs/toolkit/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/env.ts
__turbopack_context__.s([
    "Immer",
    ()=>Immer2,
    "applyPatches",
    ()=>applyPatches,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "createDraft",
    ()=>createDraft,
    "current",
    ()=>current,
    "enableMapSet",
    ()=>enableMapSet,
    "enablePatches",
    ()=>enablePatches,
    "finishDraft",
    ()=>finishDraft,
    "freeze",
    ()=>freeze,
    "immerable",
    ()=>DRAFTABLE,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "nothing",
    ()=>NOTHING,
    "original",
    ()=>original,
    "produce",
    ()=>produce,
    "produceWithPatches",
    ()=>produceWithPatches,
    "setAutoFreeze",
    ()=>setAutoFreeze,
    "setUseStrictIteration",
    ()=>setUseStrictIteration,
    "setUseStrictShallowCopy",
    ()=>setUseStrictShallowCopy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_wrap_native_super.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var NOTHING = Symbol["for"]("immer-nothing");
var DRAFTABLE = Symbol["for"]("immer-draftable");
var DRAFT_STATE = Symbol["for"]("immer-state");
// src/utils/errors.ts
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return "The plugin for '".concat(plugin, "' has not been loaded into Immer. To enable the plugin, import and call `enable").concat(plugin, "()` when initializing your application.");
    },
    function(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '".concat(thing, "'");
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return "'current' expects a draft, got: ".concat(thing);
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return "'original' expects a draft, got: ".concat(thing);
    }
] : "TURBOPACK unreachable";
function die(error) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    if ("TURBOPACK compile-time truthy", 1) {
        var e = errors[error];
        var msg = isFunction(e) ? e.apply(null, args) : e;
        throw new Error("[Immer] ".concat(msg));
    }
    throw new Error("[Immer] minified error nr: ".concat(error, ". Full error at: https://bit.ly/3cXEKWf"));
}
// src/utils/common.ts
var O = Object;
var getPrototypeOf = O.getPrototypeOf;
var CONSTRUCTOR = "constructor";
var PROTOTYPE = "prototype";
var CONFIGURABLE = "configurable";
var ENUMERABLE = "enumerable";
var WRITABLE = "writable";
var VALUE = "value";
var isDraft = function(value) {
    return !!value && !!value[DRAFT_STATE];
};
function isDraftable(value) {
    var _value_CONSTRUCTOR;
    if (!value) return false;
    return isPlainObject(value) || isArray(value) || !!value[DRAFTABLE] || !!((_value_CONSTRUCTOR = value[CONSTRUCTOR]) === null || _value_CONSTRUCTOR === void 0 ? void 0 : _value_CONSTRUCTOR[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
    if (!value || !isObjectish(value)) return false;
    var proto = getPrototypeOf(value);
    if (proto === null || proto === O[PROTOTYPE]) return true;
    var Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR];
    if (Ctor === Object) return true;
    if (!isFunction(Ctor)) return false;
    var ctorString = cachedCtorStrings.get(Ctor);
    if (ctorString === void 0) {
        ctorString = Function.toString.call(Ctor);
        cachedCtorStrings.set(Ctor, ctorString);
    }
    return ctorString === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
    var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (getArchtype(obj) === 0 /* Object */ ) {
        var keys = strict ? Reflect.ownKeys(obj) : O.keys(obj);
        keys.forEach(function(key) {
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach(function(entry, index) {
            return iter(index, entry, obj);
        });
    }
}
function getArchtype(thing) {
    var state = thing[DRAFT_STATE];
    return state ? state.type_ : isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
var has = function(thing, prop) {
    var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getArchtype(thing);
    return type === 2 /* Map */  ? thing.has(prop) : O[PROTOTYPE].hasOwnProperty.call(thing, prop);
};
var get = function(thing, prop) {
    var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getArchtype(thing);
    return(// @ts-ignore
    type === 2 /* Map */  ? thing.get(prop) : thing[prop]);
};
var set = function(thing, propOrOldValue, value) {
    var type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : getArchtype(thing);
    if (type === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (type === 3 /* Set */ ) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
};
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
var isArray = Array.isArray;
var isMap = function(target) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target, Map);
};
var isSet = function(target) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target, Set);
};
var isObjectish = function(target) {
    return (typeof target === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target)) === "object";
};
var isFunction = function(target) {
    return typeof target === "function";
};
var isBoolean = function(target) {
    return typeof target === "boolean";
};
var getProxyDraft = function(value) {
    if (!isObjectish(value)) return null;
    return value === null || value === void 0 ? void 0 : value[DRAFT_STATE];
};
var latest = function(state) {
    return state.copy_ || state.base_;
};
var getValue = function(value) {
    var proxyDraft = getProxyDraft(value);
    var _proxyDraft_copy_;
    return proxyDraft ? (_proxyDraft_copy_ = proxyDraft.copy_) !== null && _proxyDraft_copy_ !== void 0 ? _proxyDraft_copy_ : proxyDraft.base_ : value;
};
var getFinalValue = function(state) {
    return state.modified_ ? state.copy_ : state.base_;
};
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (isArray(base)) return Array[PROTOTYPE].slice.call(base);
    var isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        var descriptors = O.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        var keys = Reflect.ownKeys(descriptors);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var desc = descriptors[key];
            if (desc[WRITABLE] === false) {
                desc[WRITABLE] = true;
                desc[CONFIGURABLE] = true;
            }
            var _obj;
            if (desc.get || desc.set) descriptors[key] = (_obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, CONFIGURABLE, true), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, WRITABLE, true), // could live with !!desc.set as well here...
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, ENUMERABLE, desc[ENUMERABLE]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, VALUE, base[key]), _obj);
        }
        return O.create(getPrototypeOf(base), descriptors);
    } else {
        var proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, base);
        }
        var obj = O.create(proto);
        return O.assign(obj, base);
    }
}
function freeze(obj) {
    var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        O.defineProperties(obj, {
            set: dontMutateMethodOverride,
            add: dontMutateMethodOverride,
            clear: dontMutateMethodOverride,
            "delete": dontMutateMethodOverride
        });
    }
    O.freeze(obj);
    if (deep) each(obj, function(_key, value) {
        freeze(value, true);
    }, false);
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
var dontMutateMethodOverride = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, VALUE, dontMutateFrozenCollections);
function isFrozen(obj) {
    if (obj === null || !isObjectish(obj)) return true;
    return O.isFrozen(obj);
}
// src/utils/plugins.ts
var PluginMapSet = "MapSet";
var PluginPatches = "Patches";
var plugins = {};
function getPlugin(pluginKey) {
    var plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
var isPluginLoaded = function(pluginKey) {
    return !!plugins[pluginKey];
};
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
var getCurrentScope = function() {
    return currentScope;
};
var createScope = function(parent_, immer_) {
    return {
        drafts_: [],
        parent_: parent_,
        immer_: immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0,
        handledSet_: /* @__PURE__ */ new Set(),
        processedForPatches_: /* @__PURE__ */ new Set(),
        mapSetPlugin_: isPluginLoaded(PluginMapSet) ? getPlugin(PluginMapSet) : void 0
    };
};
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        scope.patchPlugin_ = getPlugin(PluginPatches);
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
var enterScope = function(immer2) {
    return currentScope = createScope(currentScope, immer2);
};
function revokeDraft(draft) {
    var state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    var baseDraft = scope.drafts_[0];
    var isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
        }
        var patchPlugin_ = scope.patchPlugin_;
        if (patchPlugin_) {
            patchPlugin_.generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope);
        }
    } else {
        result = finalize(scope, baseDraft);
    }
    maybeFreeze(scope, result, true);
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value) {
    if (isFrozen(value)) return value;
    var state = value[DRAFT_STATE];
    if (!state) {
        var finalValue = handleValue(value, rootScope.handledSet_, rootScope);
        return finalValue;
    }
    if (!isSameScope(state, rootScope)) {
        return value;
    }
    if (!state.modified_) {
        return state.base_;
    }
    if (!state.finalized_) {
        var callbacks_ = state.callbacks_;
        if (callbacks_) {
            while(callbacks_.length > 0){
                var callback = callbacks_.pop();
                callback(rootScope);
            }
        }
        generatePatchesAndFinalize(state, rootScope);
    }
    return state.copy_;
}
function maybeFreeze(scope, value) {
    var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
function markStateFinalized(state) {
    state.finalized_ = true;
    state.scope_.unfinalizedDrafts_--;
}
var isSameScope = function(state, rootScope) {
    return state.scope_ === rootScope;
};
var EMPTY_LOCATIONS_RESULT = [];
function updateDraftInParent(parent, draftValue, finalizedValue, originalKey) {
    var parentCopy = latest(parent);
    var parentType = parent.type_;
    if (originalKey !== void 0) {
        var currentValue = get(parentCopy, originalKey, parentType);
        if (currentValue === draftValue) {
            set(parentCopy, originalKey, finalizedValue, parentType);
            return;
        }
    }
    if (!parent.draftLocations_) {
        var draftLocations = parent.draftLocations_ = /* @__PURE__ */ new Map();
        each(parentCopy, function(key, value) {
            if (isDraft(value)) {
                var keys = draftLocations.get(value) || [];
                keys.push(key);
                draftLocations.set(value, keys);
            }
        });
    }
    var _parent_draftLocations__get;
    var locations = (_parent_draftLocations__get = parent.draftLocations_.get(draftValue)) !== null && _parent_draftLocations__get !== void 0 ? _parent_draftLocations__get : EMPTY_LOCATIONS_RESULT;
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = locations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var location = _step.value;
            set(parentCopy, location, finalizedValue, parentType);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}
function registerChildFinalizationCallback(parent, child, key) {
    parent.callbacks_.push(function childCleanup(rootScope) {
        var _rootScope_mapSetPlugin_;
        var state = child;
        if (!state || !isSameScope(state, rootScope)) {
            return;
        }
        (_rootScope_mapSetPlugin_ = rootScope.mapSetPlugin_) === null || _rootScope_mapSetPlugin_ === void 0 ? void 0 : _rootScope_mapSetPlugin_.fixSetContents(state);
        var finalizedValue = getFinalValue(state);
        var _state_draft_;
        updateDraftInParent(parent, (_state_draft_ = state.draft_) !== null && _state_draft_ !== void 0 ? _state_draft_ : state, finalizedValue, key);
        generatePatchesAndFinalize(state, rootScope);
    });
}
function generatePatchesAndFinalize(state, rootScope) {
    var _state_assigned_;
    var _state_assigned__size;
    var shouldFinalize = state.modified_ && !state.finalized_ && (state.type_ === 3 /* Set */  || ((_state_assigned__size = (_state_assigned_ = state.assigned_) === null || _state_assigned_ === void 0 ? void 0 : _state_assigned_.size) !== null && _state_assigned__size !== void 0 ? _state_assigned__size : 0) > 0);
    if (shouldFinalize) {
        var patchPlugin_ = rootScope.patchPlugin_;
        if (patchPlugin_) {
            var basePath = patchPlugin_.getPath(state);
            if (basePath) {
                patchPlugin_.generatePatches_(state, basePath, rootScope);
            }
        }
        markStateFinalized(state);
    }
}
function handleCrossReference(target, key, value) {
    var scope_ = target.scope_;
    if (isDraft(value)) {
        var state = value[DRAFT_STATE];
        if (isSameScope(state, scope_)) {
            state.callbacks_.push(function crossReferenceCleanup() {
                prepareCopy(target);
                var finalizedValue = getFinalValue(state);
                updateDraftInParent(target, value, finalizedValue, key);
            });
        }
    } else if (isDraftable(value)) {
        target.callbacks_.push(function nestedDraftCleanup() {
            var targetCopy = latest(target);
            if (get(targetCopy, key, target.type_) === value) {
                var _target_assigned__get;
                if (scope_.drafts_.length > 1 && ((_target_assigned__get = target.assigned_.get(key)) !== null && _target_assigned__get !== void 0 ? _target_assigned__get : false) === true && target.copy_) {
                    handleValue(get(target.copy_, key, target.type_), scope_.handledSet_, scope_);
                }
            }
        });
    }
}
function handleValue(target, handledSet, rootScope) {
    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
        return target;
    }
    if (isDraft(target) || handledSet.has(target) || !isDraftable(target) || isFrozen(target)) {
        return target;
    }
    handledSet.add(target);
    each(target, function(key, value) {
        if (isDraft(value)) {
            var state = value[DRAFT_STATE];
            if (isSameScope(state, rootScope)) {
                var updatedValue = getFinalValue(state);
                set(target, key, updatedValue, target.type_);
                markStateFinalized(state);
            }
        } else if (isDraftable(value)) {
            handleValue(value, handledSet, rootScope);
        }
    });
    return target;
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    var baseIsArray = isArray(base);
    var state = {
        type_: baseIsArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        // actually instantiated in `prepareCopy()`
        assigned_: void 0,
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false,
        // `callbacks` actually gets assigned in `createProxy`
        callbacks_: void 0
    };
    var target = state;
    var traps = objectTraps;
    if (baseIsArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    var _Proxy_revocable = Proxy.revocable(target, traps), revoke = _Proxy_revocable.revoke, proxy = _Proxy_revocable.proxy;
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return [
        proxy,
        state
    ];
}
var objectTraps = {
    get: function get(state, prop) {
        if (prop === DRAFT_STATE) return state;
        var source = latest(state);
        if (!has(source, prop, state.type_)) {
            return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            var childKey = state.type_ === 1 /* Array */  ? +prop : prop;
            var childDraft = createProxy(state.scope_, value, state, childKey);
            return state.copy_[childKey] = childDraft;
        }
        return value;
    },
    has: function has(state, prop) {
        return prop in latest(state);
    },
    ownKeys: function ownKeys(state) {
        return Reflect.ownKeys(latest(state));
    },
    set: function set(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            var current2 = peek(latest(state), prop);
            var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_.set(prop, false);
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop, state.type_))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_.set(prop, true);
        handleCrossReference(state, prop, value);
        return true;
    },
    deleteProperty: function deleteProperty(state, prop) {
        prepareCopy(state);
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_.set(prop, false);
            markChanged(state);
        } else {
            state.assigned_["delete"](prop);
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        var _obj;
        return _obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, WRITABLE, true), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, CONFIGURABLE, state.type_ !== 1 /* Array */  || prop !== "length"), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, ENUMERABLE, desc[ENUMERABLE]), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, VALUE, owner[prop]), _obj;
    },
    defineProperty: function defineProperty() {
        die(11);
    },
    getPrototypeOf: function getPrototypeOf1(state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf: function setPrototypeOf() {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, function(key, fn) {
    arrayTraps[key] = function() {
        var args = arguments;
        args[0] = args[0][0];
        return fn.apply(this, args);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    var state = draft[DRAFT_STATE];
    var source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    var // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    _desc_get;
    var desc = getDescriptorFromProto(source, prop);
    return desc ? VALUE in desc ? desc[VALUE] : (_desc_get = desc.get) === null || _desc_get === void 0 ? void 0 : _desc_get.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    var proto = getPrototypeOf(source);
    while(proto){
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.assigned_ = /* @__PURE__ */ new Map();
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
// src/core/immerClass.ts
var Immer2 = /*#__PURE__*/ function() {
    "use strict";
    function Immer2(config) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, Immer2);
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.useStrictIteration_ = false;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = function(base, recipe, patchListener) {
            if (isFunction(base) && !isFunction(recipe)) {
                var defaultBase = recipe;
                recipe = base;
                var self = _this;
                return function curriedProduce() {
                    var _this = this;
                    var base2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultBase;
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    var _recipe;
                    return self.produce(base2, function(draft) {
                        return (_recipe = recipe).call.apply(_recipe, [
                            _this,
                            draft
                        ].concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args)));
                    });
                };
            }
            if (!isFunction(recipe)) die(6);
            if (patchListener !== void 0 && !isFunction(patchListener)) die(7);
            var result;
            if (isDraftable(base)) {
                var scope = enterScope(_this);
                var proxy = createProxy(scope, base, void 0);
                var hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || !isObjectish(base)) {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (_this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    var p = [];
                    var ip = [];
                    getPlugin(PluginPatches).generateReplacementPatches_(base, result, {
                        patches_: p,
                        inversePatches_: ip
                    });
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = function(base, recipe) {
            if (isFunction(base)) {
                var _this1 = _this;
                return function(state) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    return _this1.produceWithPatches(state, function(draft) {
                        return base.apply(void 0, [
                            draft
                        ].concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args)));
                    });
                };
            }
            var patches, inversePatches;
            var result = _this.produce(base, recipe, function(p, ip) {
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (isBoolean(config === null || config === void 0 ? void 0 : config.autoFreeze)) this.setAutoFreeze(config.autoFreeze);
        if (isBoolean(config === null || config === void 0 ? void 0 : config.useStrictShallowCopy)) this.setUseStrictShallowCopy(config.useStrictShallowCopy);
        if (isBoolean(config === null || config === void 0 ? void 0 : config.useStrictIteration)) this.setUseStrictIteration(config.useStrictIteration);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Immer2, [
        {
            key: "createDraft",
            value: function createDraft(base) {
                if (!isDraftable(base)) die(8);
                if (isDraft(base)) base = current(base);
                var scope = enterScope(this);
                var proxy = createProxy(scope, base, void 0);
                proxy[DRAFT_STATE].isManual_ = true;
                leaveScope(scope);
                return proxy;
            }
        },
        {
            key: "finishDraft",
            value: function finishDraft(draft, patchListener) {
                var state = draft && draft[DRAFT_STATE];
                if (!state || !state.isManual_) die(9);
                var scope = state.scope_;
                usePatchesInScope(scope, patchListener);
                return processResult(void 0, scope);
            }
        },
        {
            /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ key: "setAutoFreeze",
            value: function setAutoFreeze(value) {
                this.autoFreeze_ = value;
            }
        },
        {
            /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ key: "setUseStrictShallowCopy",
            value: function setUseStrictShallowCopy(value) {
                this.useStrictShallowCopy_ = value;
            }
        },
        {
            /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */ key: "setUseStrictIteration",
            value: function setUseStrictIteration(value) {
                this.useStrictIteration_ = value;
            }
        },
        {
            key: "shouldUseStrictIteration",
            value: function shouldUseStrictIteration() {
                return this.useStrictIteration_;
            }
        },
        {
            key: "applyPatches",
            value: function applyPatches(base, patches) {
                var i;
                for(i = patches.length - 1; i >= 0; i--){
                    var patch = patches[i];
                    if (patch.path.length === 0 && patch.op === "replace") {
                        base = patch.value;
                        break;
                    }
                }
                if (i > -1) {
                    patches = patches.slice(i + 1);
                }
                var applyPatchesImpl = getPlugin(PluginPatches).applyPatches_;
                if (isDraft(base)) {
                    return applyPatchesImpl(base, patches);
                }
                return this.produce(base, function(draft) {
                    return applyPatchesImpl(draft, patches);
                });
            }
        }
    ]);
    return Immer2;
}();
function createProxy(rootScope, value, parent, key) {
    var _ref = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(isMap(value) ? getPlugin(PluginMapSet).proxyMap_(value, parent) : isSet(value) ? getPlugin(PluginMapSet).proxySet_(value, parent) : createProxyProxy(value, parent), 2), draft = _ref[0], state = _ref[1];
    var _parent_scope_;
    var scope = (_parent_scope_ = parent === null || parent === void 0 ? void 0 : parent.scope_) !== null && _parent_scope_ !== void 0 ? _parent_scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    var _parent_callbacks_;
    state.callbacks_ = (_parent_callbacks_ = parent === null || parent === void 0 ? void 0 : parent.callbacks_) !== null && _parent_callbacks_ !== void 0 ? _parent_callbacks_ : [];
    state.key_ = key;
    if (parent && key !== void 0) {
        registerChildFinalizationCallback(parent, state, key);
    } else {
        state.callbacks_.push(function rootDraftCleanup(rootScope2) {
            var _rootScope2_mapSetPlugin_;
            (_rootScope2_mapSetPlugin_ = rootScope2.mapSetPlugin_) === null || _rootScope2_mapSetPlugin_ === void 0 ? void 0 : _rootScope2_mapSetPlugin_.fixSetContents(state);
            var patchPlugin_ = rootScope2.patchPlugin_;
            if (state.modified_ && patchPlugin_) {
                patchPlugin_.generatePatches_(state, [], rootScope2);
            }
        });
    }
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    var state = value[DRAFT_STATE];
    var copy;
    var strict = true;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
        strict = state.scope_.immer_.shouldUseStrictIteration();
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, function(key, childValue) {
        set(copy, key, currentImpl(childValue));
    }, strict);
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    var errorOffset = 16;
    if ("TURBOPACK compile-time truthy", 1) {
        errors.push('Sets cannot have "replace" patches.', function(op) {
            return "Unsupported patch operation: " + op;
        }, function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
        }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    }
    function getPath(state) {
        var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        if ("key_" in state && state.key_ !== void 0) {
            var _state_parent__copy_;
            var parentCopy = (_state_parent__copy_ = state.parent_.copy_) !== null && _state_parent__copy_ !== void 0 ? _state_parent__copy_ : state.parent_.base_;
            var proxyDraft = getProxyDraft(get(parentCopy, state.key_));
            var valueAtKey = get(parentCopy, state.key_);
            if (valueAtKey === void 0) {
                return null;
            }
            if (valueAtKey !== state.draft_ && valueAtKey !== state.base_ && valueAtKey !== state.copy_) {
                return null;
            }
            if (proxyDraft != null && proxyDraft.base_ !== state.base_) {
                return null;
            }
            var isSet2 = state.parent_.type_ === 3 /* Set */ ;
            var key;
            if (isSet2) {
                var setParent = state.parent_;
                key = Array.from(setParent.drafts_.keys()).indexOf(state.key_);
            } else {
                key = state.key_;
            }
            if (!(isSet2 && parentCopy.size > key || has(parentCopy, key))) {
                return null;
            }
            path.push(key);
        }
        if (state.parent_) {
            return getPath(state.parent_, path);
        }
        path.reverse();
        try {
            resolvePath(state.copy_, path);
        } catch (e) {
            return null;
        }
        return path;
    }
    function resolvePath(base, path) {
        var current2 = base;
        for(var i = 0; i < path.length - 1; i++){
            var key = path[i];
            current2 = get(current2, key);
            if (!isObjectish(current2) || current2 === null) {
                throw new Error("Cannot resolve path at '".concat(path.join("/"), "'"));
            }
        }
        return current2;
    }
    var REPLACE = "replace";
    var ADD = "add";
    var REMOVE = "remove";
    function generatePatches_(state, basePath, scope) {
        if (state.scope_.processedForPatches_.has(state)) {
            return;
        }
        state.scope_.processedForPatches_.add(state);
        var patches_ = scope.patches_, inversePatches_ = scope.inversePatches_;
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches_, inversePatches_);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches_, inversePatches_);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches_, inversePatches_);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
            ;
            var ref;
            ref = [
                copy_,
                base_
            ], base_ = ref[0], copy_ = ref[1], ref;
            var ref1;
            ref1 = [
                inversePatches,
                patches
            ], patches = ref1[0], inversePatches = ref1[1], ref1;
        }
        for(var i = 0; i < base_.length; i++){
            var copiedItem = copy_[i];
            var baseItem = base_[i];
            if ((assigned_ === null || assigned_ === void 0 ? void 0 : assigned_.get(i.toString())) && copiedItem !== baseItem) {
                var childState = copiedItem === null || copiedItem === void 0 ? void 0 : copiedItem[DRAFT_STATE];
                if (childState && childState.modified_) {
                    continue;
                }
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REPLACE,
                    path: path,
                    // Need to maybe clone it, as it can in fact be the original value
                    // due to the base/copy inversion at the start of this function
                    value: clonePatchValueIfNeeded(copiedItem)
                });
                inversePatches.push({
                    op: REPLACE,
                    path: path,
                    value: clonePatchValueIfNeeded(baseItem)
                });
            }
        }
        for(var i1 = base_.length; i1 < copy_.length; i1++){
            var path1 = basePath.concat([
                i1
            ]);
            patches.push({
                op: ADD,
                path: path1,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i1])
            });
        }
        for(var i2 = copy_.length - 1; base_.length <= i2; --i2){
            var path2 = basePath.concat([
                i2
            ]);
            inversePatches.push({
                op: REMOVE,
                path: path2
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_, type_ = state.type_;
        each(state.assigned_, function(key, assignedValue) {
            var origValue = get(base_, key, type_);
            var value = get(copy_, key, type_);
            var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            var path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op: op,
                path: path
            } : {
                op: op,
                path: path,
                value: clonePatchValueIfNeeded(value)
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path: path
            } : op === REMOVE ? {
                op: ADD,
                path: path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path: path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i = 0;
        base_.forEach(function(value) {
            if (!copy_.has(value)) {
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path: path,
                    value: value
                });
                inversePatches.unshift({
                    op: ADD,
                    path: path,
                    value: value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach(function(value) {
            if (!base_.has(value)) {
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path: path,
                    value: value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path: path,
                    value: value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, scope) {
        var patches_ = scope.patches_, inversePatches_ = scope.inversePatches_;
        patches_.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches_.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
            var path = patch.path, op = patch.op;
            var base = draft;
            for(var i = 0; i < path.length - 1; i++){
                var parentType = getArchtype(base);
                var p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                    p = "" + p;
                }
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === CONSTRUCTOR)) die(errorOffset + 3);
                if (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3);
                base = get(base, p);
                if (!isObjectish(base)) die(errorOffset + 2, path.join("/"));
            }
            var type = getArchtype(base);
            var value = deepClonePatchValue(patch.value);
            var key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base["delete"](key);
                        case 3 /* Set */ :
                            return base["delete"](patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function(param) {
            var _param = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(param, 2), k = _param[0], v = _param[1];
            return [
                k,
                deepClonePatchValue(v)
            ];
        }));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(getPrototypeOf(obj));
        for(var key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
            return deepClonePatchValue(obj);
        } else return obj;
    }
    loadPlugin(PluginPatches, {
        applyPatches_: applyPatches_,
        generatePatches_: generatePatches_,
        generateReplacementPatches_: generateReplacementPatches_,
        getPath: getPath
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    var DraftMap = /*#__PURE__*/ function(Map1) {
        "use strict";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftMap, Map1);
        function DraftMap(target, parent) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftMap);
            var _this;
            _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftMap);
            _this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: _this,
                isManual_: false,
                revoked_: false,
                callbacks_: []
            };
            return _this;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftMap, [
            {
                key: "size",
                get: function get() {
                    return latest(this[DRAFT_STATE]).size;
                }
            },
            {
                key: "has",
                value: function has(key) {
                    return latest(this[DRAFT_STATE]).has(key);
                }
            },
            {
                key: "set",
                value: function set(key, value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!latest(state).has(key) || latest(state).get(key) !== value) {
                        prepareMapCopy(state);
                        markChanged(state);
                        state.assigned_.set(key, true);
                        state.copy_.set(key, value);
                        state.assigned_.set(key, true);
                    }
                    return this;
                }
            },
            {
                key: "delete",
                value: function _delete(key) {
                    if (!this.has(key)) {
                        return false;
                    }
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareMapCopy(state);
                    markChanged(state);
                    if (state.base_.has(key)) {
                        state.assigned_.set(key, false);
                    } else {
                        state.assigned_["delete"](key);
                    }
                    state.copy_["delete"](key);
                    return true;
                }
            },
            {
                key: "clear",
                value: function clear() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (latest(state).size) {
                        prepareMapCopy(state);
                        markChanged(state);
                        state.assigned_ = /* @__PURE__ */ new Map();
                        each(state.base_, function(key) {
                            state.assigned_.set(key, false);
                        });
                        state.copy_.clear();
                    }
                }
            },
            {
                key: "forEach",
                value: function forEach(cb, thisArg) {
                    var _this = this;
                    var state = this[DRAFT_STATE];
                    latest(state).forEach(function(_value, key, _map) {
                        cb.call(thisArg, _this.get(key), key, _this);
                    });
                }
            },
            {
                key: "get",
                value: function get(key) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    var value = latest(state).get(key);
                    if (state.finalized_ || !isDraftable(value)) {
                        return value;
                    }
                    if (value !== state.base_.get(key)) {
                        return value;
                    }
                    var draft = createProxy(state.scope_, value, state, key);
                    prepareMapCopy(state);
                    state.copy_.set(key, draft);
                    return draft;
                }
            },
            {
                key: "keys",
                value: function keys() {
                    return latest(this[DRAFT_STATE]).keys();
                }
            },
            {
                key: "values",
                value: function values() {
                    var _this = this;
                    var iterator = this.keys();
                    var _obj;
                    return _obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, Symbol.iterator, function() {
                        return _this.values();
                    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, "next", function() {
                        var r = iterator.next();
                        if (r.done) return r;
                        var value = _this.get(r.value);
                        return {
                            done: false,
                            value: value
                        };
                    }), _obj;
                }
            },
            {
                key: "entries",
                value: function entries() {
                    var _this = this;
                    var iterator = this.keys();
                    var _obj;
                    return _obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, Symbol.iterator, function() {
                        return _this.entries();
                    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, "next", function() {
                        var r = iterator.next();
                        if (r.done) return r;
                        var value = _this.get(r.value);
                        return {
                            done: false,
                            value: [
                                r.value,
                                value
                            ]
                        };
                    }), _obj;
                }
            },
            {
                key: (DRAFT_STATE, Symbol.iterator),
                value: function value() {
                    return this.entries();
                }
            }
        ]);
        return DraftMap;
    }((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Map));
    function proxyMap_(target, parent) {
        var map = new DraftMap(target, parent);
        return [
            map,
            map[DRAFT_STATE]
        ];
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    var DraftSet = /*#__PURE__*/ function(Set1) {
        "use strict";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftSet, Set1);
        function DraftSet(target, parent) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftSet);
            var _this;
            _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftSet);
            _this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: _this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false,
                assigned_: void 0,
                callbacks_: []
            };
            return _this;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftSet, [
            {
                key: "size",
                get: function get() {
                    return latest(this[DRAFT_STATE]).size;
                }
            },
            {
                key: "has",
                value: function has(value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!state.copy_) {
                        return state.base_.has(value);
                    }
                    if (state.copy_.has(value)) return true;
                    if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
                    return false;
                }
            },
            {
                key: "add",
                value: function add(value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!this.has(value)) {
                        prepareSetCopy(state);
                        markChanged(state);
                        state.copy_.add(value);
                    }
                    return this;
                }
            },
            {
                key: "delete",
                value: function _delete(value) {
                    if (!this.has(value)) {
                        return false;
                    }
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    markChanged(state);
                    return state.copy_["delete"](value) || (state.drafts_.has(value) ? state.copy_["delete"](state.drafts_.get(value)) : /* istanbul ignore next */ false);
                }
            },
            {
                key: "clear",
                value: function clear() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (latest(state).size) {
                        prepareSetCopy(state);
                        markChanged(state);
                        state.copy_.clear();
                    }
                }
            },
            {
                key: "values",
                value: function values() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    return state.copy_.values();
                }
            },
            {
                key: "entries",
                value: function entries() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    return state.copy_.entries();
                }
            },
            {
                key: "keys",
                value: function keys() {
                    return this.values();
                }
            },
            {
                key: (DRAFT_STATE, Symbol.iterator),
                value: function value() {
                    return this.values();
                }
            },
            {
                key: "forEach",
                value: function forEach(cb, thisArg) {
                    var iterator = this.values();
                    var result = iterator.next();
                    while(!result.done){
                        cb.call(thisArg, result.value, result.value, this);
                        result = iterator.next();
                    }
                }
            }
        ]);
        return DraftSet;
    }((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Set));
    function proxySet_(target, parent) {
        var set2 = new DraftSet(target, parent);
        return [
            set2,
            set2[DRAFT_STATE]
        ];
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach(function(value) {
                if (isDraftable(value)) {
                    var draft = createProxy(state.scope_, value, state, value);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else {
                    state.copy_.add(value);
                }
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    function fixSetContents(target) {
        if (target.type_ === 3 /* Set */  && target.copy_) {
            var copy = new Set(target.copy_);
            target.copy_.clear();
            copy.forEach(function(value) {
                target.copy_.add(getValue(value));
            });
        }
    }
    loadPlugin(PluginMapSet, {
        proxyMap_: proxyMap_,
        proxySet_: proxySet_,
        fixSetContents: fixSetContents
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);
var setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);
var setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);
var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
var createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);
var finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);
var castDraft = function(value) {
    return value;
};
var castImmutable = function(value) {
    return value;
};
;
 //# sourceMappingURL=immer.mjs.map
}),
"[project]/node_modules/immer/dist/immer.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// src/utils/env.ts
__turbopack_context__.s([
    "Immer",
    ()=>Immer2,
    "applyPatches",
    ()=>applyPatches,
    "castDraft",
    ()=>castDraft,
    "castImmutable",
    ()=>castImmutable,
    "createDraft",
    ()=>createDraft,
    "current",
    ()=>current,
    "enableMapSet",
    ()=>enableMapSet,
    "enablePatches",
    ()=>enablePatches,
    "finishDraft",
    ()=>finishDraft,
    "freeze",
    ()=>freeze,
    "immerable",
    ()=>DRAFTABLE,
    "isDraft",
    ()=>isDraft,
    "isDraftable",
    ()=>isDraftable,
    "nothing",
    ()=>NOTHING,
    "original",
    ()=>original,
    "produce",
    ()=>produce,
    "produceWithPatches",
    ()=>produceWithPatches,
    "setAutoFreeze",
    ()=>setAutoFreeze,
    "setUseStrictIteration",
    ()=>setUseStrictIteration,
    "setUseStrictShallowCopy",
    ()=>setUseStrictShallowCopy
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_call_super.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_class_call_check.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_create_class.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_define_property.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_inherits.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_instanceof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_object_spread.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_sliced_to_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_to_consumable_array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_type_of.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@swc/helpers/esm/_wrap_native_super.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
var NOTHING = Symbol["for"]("immer-nothing");
var DRAFTABLE = Symbol["for"]("immer-draftable");
var DRAFT_STATE = Symbol["for"]("immer-state");
// src/utils/errors.ts
var errors = ("TURBOPACK compile-time truthy", 1) ? [
    // All error codes, starting by 0:
    function(plugin) {
        return "The plugin for '".concat(plugin, "' has not been loaded into Immer. To enable the plugin, import and call `enable").concat(plugin, "()` when initializing your application.");
    },
    function(thing) {
        return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '".concat(thing, "'");
    },
    "This object has been frozen and should not be mutated",
    function(data) {
        return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
    },
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
    "Immer forbids circular references",
    "The first or second argument to `produce` must be a function",
    "The third argument to `produce` must be a function or undefined",
    "First argument to `createDraft` must be a plain object, an array, or an immerable object",
    "First argument to `finishDraft` must be a draft returned by `createDraft`",
    function(thing) {
        return "'current' expects a draft, got: ".concat(thing);
    },
    "Object.defineProperty() cannot be used on an Immer draft",
    "Object.setPrototypeOf() cannot be used on an Immer draft",
    "Immer only supports deleting array indices",
    "Immer only supports setting array indices and the 'length' property",
    function(thing) {
        return "'original' expects a draft, got: ".concat(thing);
    }
] : "TURBOPACK unreachable";
function die(error) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    if ("TURBOPACK compile-time truthy", 1) {
        var e = errors[error];
        var msg = typeof e === "function" ? e.apply(null, args) : e;
        throw new Error("[Immer] ".concat(msg));
    }
    throw new Error("[Immer] minified error nr: ".concat(error, ". Full error at: https://bit.ly/3cXEKWf"));
}
// src/utils/common.ts
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
    return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
    var _value_constructor;
    if (!value) return false;
    return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!((_value_constructor = value.constructor) === null || _value_constructor === void 0 ? void 0 : _value_constructor[DRAFTABLE]) || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
var cachedCtorStrings = /* @__PURE__ */ new WeakMap();
function isPlainObject(value) {
    if (!value || (typeof value === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(value)) !== "object") return false;
    var proto = Object.getPrototypeOf(value);
    if (proto === null || proto === Object.prototype) return true;
    var Ctor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    if (Ctor === Object) return true;
    if (typeof Ctor !== "function") return false;
    var ctorString = cachedCtorStrings.get(Ctor);
    if (ctorString === void 0) {
        ctorString = Function.toString.call(Ctor);
        cachedCtorStrings.set(Ctor, ctorString);
    }
    return ctorString === objectCtorString;
}
function original(value) {
    if (!isDraft(value)) die(15, value);
    return value[DRAFT_STATE].base_;
}
function each(obj, iter) {
    var strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (getArchtype(obj) === 0 /* Object */ ) {
        var keys = strict ? Reflect.ownKeys(obj) : Object.keys(obj);
        keys.forEach(function(key) {
            iter(key, obj[key], obj);
        });
    } else {
        obj.forEach(function(entry, index) {
            return iter(index, entry, obj);
        });
    }
}
function getArchtype(thing) {
    var state = thing[DRAFT_STATE];
    return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */  : isMap(thing) ? 2 /* Map */  : isSet(thing) ? 3 /* Set */  : 0 /* Object */ ;
}
function has(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function get(thing, prop) {
    return getArchtype(thing) === 2 /* Map */  ? thing.get(prop) : thing[prop];
}
function set(thing, propOrOldValue, value) {
    var t = getArchtype(thing);
    if (t === 2 /* Map */ ) thing.set(propOrOldValue, value);
    else if (t === 3 /* Set */ ) {
        thing.add(value);
    } else thing[propOrOldValue] = value;
}
function is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}
function isMap(target) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target, Map);
}
function isSet(target) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_instanceof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(target, Set);
}
function latest(state) {
    return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
    if (isMap(base)) {
        return new Map(base);
    }
    if (isSet(base)) {
        return new Set(base);
    }
    if (Array.isArray(base)) return Array.prototype.slice.call(base);
    var isPlain = isPlainObject(base);
    if (strict === true || strict === "class_only" && !isPlain) {
        var descriptors = Object.getOwnPropertyDescriptors(base);
        delete descriptors[DRAFT_STATE];
        var keys = Reflect.ownKeys(descriptors);
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var desc = descriptors[key];
            if (desc.writable === false) {
                desc.writable = true;
                desc.configurable = true;
            }
            if (desc.get || desc.set) descriptors[key] = {
                configurable: true,
                writable: true,
                // could live with !!desc.set as well here...
                enumerable: desc.enumerable,
                value: base[key]
            };
        }
        return Object.create(getPrototypeOf(base), descriptors);
    } else {
        var proto = getPrototypeOf(base);
        if (proto !== null && isPlain) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_object_spread$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])({}, base);
        }
        var obj = Object.create(proto);
        return Object.assign(obj, base);
    }
}
function freeze(obj) {
    var deep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
    if (getArchtype(obj) > 1) {
        Object.defineProperties(obj, {
            set: dontMutateMethodOverride,
            add: dontMutateMethodOverride,
            clear: dontMutateMethodOverride,
            "delete": dontMutateMethodOverride
        });
    }
    Object.freeze(obj);
    if (deep) Object.values(obj).forEach(function(value) {
        return freeze(value, true);
    });
    return obj;
}
function dontMutateFrozenCollections() {
    die(2);
}
var dontMutateMethodOverride = {
    value: dontMutateFrozenCollections
};
function isFrozen(obj) {
    if (obj === null || (typeof obj === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(obj)) !== "object") return true;
    return Object.isFrozen(obj);
}
// src/utils/plugins.ts
var plugins = {};
function getPlugin(pluginKey) {
    var plugin = plugins[pluginKey];
    if (!plugin) {
        die(0, pluginKey);
    }
    return plugin;
}
function loadPlugin(pluginKey, implementation) {
    if (!plugins[pluginKey]) plugins[pluginKey] = implementation;
}
// src/core/scope.ts
var currentScope;
function getCurrentScope() {
    return currentScope;
}
function createScope(parent_, immer_) {
    return {
        drafts_: [],
        parent_: parent_,
        immer_: immer_,
        // Whenever the modified draft contains a draft from another scope, we
        // need to prevent auto-freezing so the unowned draft can be finalized.
        canAutoFreeze_: true,
        unfinalizedDrafts_: 0
    };
}
function usePatchesInScope(scope, patchListener) {
    if (patchListener) {
        getPlugin("Patches");
        scope.patches_ = [];
        scope.inversePatches_ = [];
        scope.patchListener_ = patchListener;
    }
}
function revokeScope(scope) {
    leaveScope(scope);
    scope.drafts_.forEach(revokeDraft);
    scope.drafts_ = null;
}
function leaveScope(scope) {
    if (scope === currentScope) {
        currentScope = scope.parent_;
    }
}
function enterScope(immer2) {
    return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
    var state = draft[DRAFT_STATE];
    if (state.type_ === 0 /* Object */  || state.type_ === 1 /* Array */ ) state.revoke_();
    else state.revoked_ = true;
}
// src/core/finalize.ts
function processResult(result, scope) {
    scope.unfinalizedDrafts_ = scope.drafts_.length;
    var baseDraft = scope.drafts_[0];
    var isReplaced = result !== void 0 && result !== baseDraft;
    if (isReplaced) {
        if (baseDraft[DRAFT_STATE].modified_) {
            revokeScope(scope);
            die(4);
        }
        if (isDraftable(result)) {
            result = finalize(scope, result);
            if (!scope.parent_) maybeFreeze(scope, result);
        }
        if (scope.patches_) {
            getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
        }
    } else {
        result = finalize(scope, baseDraft, []);
    }
    revokeScope(scope);
    if (scope.patches_) {
        scope.patchListener_(scope.patches_, scope.inversePatches_);
    }
    return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path) {
    if (isFrozen(value)) return value;
    var useStrictIteration = rootScope.immer_.shouldUseStrictIteration();
    var state = value[DRAFT_STATE];
    if (!state) {
        each(value, function(key, childValue) {
            return finalizeProperty(rootScope, state, value, key, childValue, path);
        }, useStrictIteration);
        return value;
    }
    if (state.scope_ !== rootScope) return value;
    if (!state.modified_) {
        maybeFreeze(rootScope, state.base_, true);
        return state.base_;
    }
    if (!state.finalized_) {
        state.finalized_ = true;
        state.scope_.unfinalizedDrafts_--;
        var result = state.copy_;
        var resultEach = result;
        var isSet2 = false;
        if (state.type_ === 3 /* Set */ ) {
            resultEach = new Set(result);
            result.clear();
            isSet2 = true;
        }
        each(resultEach, function(key, childValue) {
            return finalizeProperty(rootScope, state, result, key, childValue, path, isSet2);
        }, useStrictIteration);
        maybeFreeze(rootScope, result, false);
        if (path && rootScope.patches_) {
            getPlugin("Patches").generatePatches_(state, path, rootScope.patches_, rootScope.inversePatches_);
        }
    }
    return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
    if (childValue == null) {
        return;
    }
    if ((typeof childValue === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(childValue)) !== "object" && !targetIsSet) {
        return;
    }
    var childIsFrozen = isFrozen(childValue);
    if (childIsFrozen && !targetIsSet) {
        return;
    }
    if (("TURBOPACK compile-time value", "development") !== "production" && childValue === targetObject) die(5);
    if (isDraft(childValue)) {
        var path = rootPath && parentState && parentState.type_ !== 3 /* Set */  && // Set objects are atomic since they have no keys.
        !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
        var res = finalize(rootScope, childValue, path);
        set(targetObject, prop, res);
        if (isDraft(res)) {
            rootScope.canAutoFreeze_ = false;
        } else return;
    } else if (targetIsSet) {
        targetObject.add(childValue);
    }
    if (isDraftable(childValue) && !childIsFrozen) {
        if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {
            return;
        }
        if (parentState && parentState.base_ && parentState.base_[prop] === childValue && childIsFrozen) {
            return;
        }
        finalize(rootScope, childValue);
        if ((!parentState || !parentState.scope_.parent_) && (typeof prop === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(prop)) !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop))) maybeFreeze(rootScope, childValue);
    }
}
function maybeFreeze(scope, value) {
    var deep = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {
        freeze(value, deep);
    }
}
// src/core/proxy.ts
function createProxyProxy(base, parent) {
    var isArray = Array.isArray(base);
    var state = {
        type_: isArray ? 1 /* Array */  : 0 /* Object */ ,
        // Track which produce call this is associated with.
        scope_: parent ? parent.scope_ : getCurrentScope(),
        // True for both shallow and deep changes.
        modified_: false,
        // Used during finalization.
        finalized_: false,
        // Track which properties have been assigned (true) or deleted (false).
        assigned_: {},
        // The parent draft state.
        parent_: parent,
        // The base state.
        base_: base,
        // The base proxy.
        draft_: null,
        // set below
        // The base copy with any updated values.
        copy_: null,
        // Called by the `produce` function.
        revoke_: null,
        isManual_: false
    };
    var target = state;
    var traps = objectTraps;
    if (isArray) {
        target = [
            state
        ];
        traps = arrayTraps;
    }
    var _Proxy_revocable = Proxy.revocable(target, traps), revoke = _Proxy_revocable.revoke, proxy = _Proxy_revocable.proxy;
    state.draft_ = proxy;
    state.revoke_ = revoke;
    return proxy;
}
var objectTraps = {
    get: function get(state, prop) {
        if (prop === DRAFT_STATE) return state;
        var source = latest(state);
        if (!has(source, prop)) {
            return readPropFromProto(state, source, prop);
        }
        var value = source[prop];
        if (state.finalized_ || !isDraftable(value)) {
            return value;
        }
        if (value === peek(state.base_, prop)) {
            prepareCopy(state);
            return state.copy_[prop] = createProxy(value, state);
        }
        return value;
    },
    has: function has(state, prop) {
        return prop in latest(state);
    },
    ownKeys: function ownKeys(state) {
        return Reflect.ownKeys(latest(state));
    },
    set: function set(state, prop, value) {
        var desc = getDescriptorFromProto(latest(state), prop);
        if (desc === null || desc === void 0 ? void 0 : desc.set) {
            desc.set.call(state.draft_, value);
            return true;
        }
        if (!state.modified_) {
            var current2 = peek(latest(state), prop);
            var currentState = current2 === null || current2 === void 0 ? void 0 : current2[DRAFT_STATE];
            if (currentState && currentState.base_ === value) {
                state.copy_[prop] = value;
                state.assigned_[prop] = false;
                return true;
            }
            if (is(value, current2) && (value !== void 0 || has(state.base_, prop))) return true;
            prepareCopy(state);
            markChanged(state);
        }
        if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'
        (value !== void 0 || prop in state.copy_) || // special case: NaN
        Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
        state.copy_[prop] = value;
        state.assigned_[prop] = true;
        return true;
    },
    deleteProperty: function deleteProperty(state, prop) {
        if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
            state.assigned_[prop] = false;
            prepareCopy(state);
            markChanged(state);
        } else {
            delete state.assigned_[prop];
        }
        if (state.copy_) {
            delete state.copy_[prop];
        }
        return true;
    },
    // Note: We never coerce `desc.value` into an Immer draft, because we can't make
    // the same guarantee in ES5 mode.
    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(state, prop) {
        var owner = latest(state);
        var desc = Reflect.getOwnPropertyDescriptor(owner, prop);
        if (!desc) return desc;
        return {
            writable: true,
            configurable: state.type_ !== 1 /* Array */  || prop !== "length",
            enumerable: desc.enumerable,
            value: owner[prop]
        };
    },
    defineProperty: function defineProperty() {
        die(11);
    },
    getPrototypeOf: function getPrototypeOf1(state) {
        return getPrototypeOf(state.base_);
    },
    setPrototypeOf: function setPrototypeOf() {
        die(12);
    }
};
var arrayTraps = {};
each(objectTraps, function(key, fn) {
    arrayTraps[key] = function() {
        arguments[0] = arguments[0][0];
        return fn.apply(this, arguments);
    };
});
arrayTraps.deleteProperty = function(state, prop) {
    if (("TURBOPACK compile-time value", "development") !== "production" && isNaN(parseInt(prop))) die(13);
    return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
    if (("TURBOPACK compile-time value", "development") !== "production" && prop !== "length" && isNaN(parseInt(prop))) die(14);
    return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
    var state = draft[DRAFT_STATE];
    var source = state ? latest(state) : draft;
    return source[prop];
}
function readPropFromProto(state, source, prop) {
    var // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    _desc_get;
    var desc = getDescriptorFromProto(source, prop);
    return desc ? "value" in desc ? desc.value : (_desc_get = desc.get) === null || _desc_get === void 0 ? void 0 : _desc_get.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
    if (!(prop in source)) return void 0;
    var proto = getPrototypeOf(source);
    while(proto){
        var desc = Object.getOwnPropertyDescriptor(proto, prop);
        if (desc) return desc;
        proto = getPrototypeOf(proto);
    }
    return void 0;
}
function markChanged(state) {
    if (!state.modified_) {
        state.modified_ = true;
        if (state.parent_) {
            markChanged(state.parent_);
        }
    }
}
function prepareCopy(state) {
    if (!state.copy_) {
        state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
    }
}
// src/core/immerClass.ts
var Immer2 = /*#__PURE__*/ function() {
    "use strict";
    function Immer2(config) {
        var _this = this;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, Immer2);
        this.autoFreeze_ = true;
        this.useStrictShallowCopy_ = false;
        this.useStrictIteration_ = true;
        /**
     * The `produce` function takes a value and a "recipe function" (whose
     * return value often depends on the base state). The recipe function is
     * free to mutate its first argument however it wants. All mutations are
     * only ever applied to a __copy__ of the base state.
     *
     * Pass only a function to create a "curried producer" which relieves you
     * from passing the recipe function every time.
     *
     * Only plain objects and arrays are made mutable. All other objects are
     * considered uncopyable.
     *
     * Note: This function is __bound__ to its `Immer` instance.
     *
     * @param {any} base - the initial state
     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
     * @param {Function} patchListener - optional function that will be called with all the patches produced here
     * @returns {any} a new state, or the initial state if nothing was modified
     */ this.produce = function(base, recipe, patchListener) {
            if (typeof base === "function" && typeof recipe !== "function") {
                var defaultBase = recipe;
                recipe = base;
                var self = _this;
                return function curriedProduce() {
                    var _this = this;
                    var base2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultBase;
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    var _recipe;
                    return self.produce(base2, function(draft) {
                        return (_recipe = recipe).call.apply(_recipe, [
                            _this,
                            draft
                        ].concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args)));
                    });
                };
            }
            if (typeof recipe !== "function") die(6);
            if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
            var result;
            if (isDraftable(base)) {
                var scope = enterScope(_this);
                var proxy = createProxy(base, void 0);
                var hasError = true;
                try {
                    result = recipe(proxy);
                    hasError = false;
                } finally{
                    if (hasError) revokeScope(scope);
                    else leaveScope(scope);
                }
                usePatchesInScope(scope, patchListener);
                return processResult(result, scope);
            } else if (!base || (typeof base === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(base)) !== "object") {
                result = recipe(base);
                if (result === void 0) result = base;
                if (result === NOTHING) result = void 0;
                if (_this.autoFreeze_) freeze(result, true);
                if (patchListener) {
                    var p = [];
                    var ip = [];
                    getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
                    patchListener(p, ip);
                }
                return result;
            } else die(1, base);
        };
        this.produceWithPatches = function(base, recipe) {
            if (typeof base === "function") {
                var _this1 = _this;
                return function(state) {
                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        args[_key - 1] = arguments[_key];
                    }
                    return _this1.produceWithPatches(state, function(draft) {
                        return base.apply(void 0, [
                            draft
                        ].concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_to_consumable_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(args)));
                    });
                };
            }
            var patches, inversePatches;
            var result = _this.produce(base, recipe, function(p, ip) {
                patches = p;
                inversePatches = ip;
            });
            return [
                result,
                patches,
                inversePatches
            ];
        };
        if (typeof (config === null || config === void 0 ? void 0 : config.autoFreeze) === "boolean") this.setAutoFreeze(config.autoFreeze);
        if (typeof (config === null || config === void 0 ? void 0 : config.useStrictShallowCopy) === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
        if (typeof (config === null || config === void 0 ? void 0 : config.useStrictIteration) === "boolean") this.setUseStrictIteration(config.useStrictIteration);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Immer2, [
        {
            key: "createDraft",
            value: function createDraft(base) {
                if (!isDraftable(base)) die(8);
                if (isDraft(base)) base = current(base);
                var scope = enterScope(this);
                var proxy = createProxy(base, void 0);
                proxy[DRAFT_STATE].isManual_ = true;
                leaveScope(scope);
                return proxy;
            }
        },
        {
            key: "finishDraft",
            value: function finishDraft(draft, patchListener) {
                var state = draft && draft[DRAFT_STATE];
                if (!state || !state.isManual_) die(9);
                var scope = state.scope_;
                usePatchesInScope(scope, patchListener);
                return processResult(void 0, scope);
            }
        },
        {
            /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */ key: "setAutoFreeze",
            value: function setAutoFreeze(value) {
                this.autoFreeze_ = value;
            }
        },
        {
            /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */ key: "setUseStrictShallowCopy",
            value: function setUseStrictShallowCopy(value) {
                this.useStrictShallowCopy_ = value;
            }
        },
        {
            /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */ key: "setUseStrictIteration",
            value: function setUseStrictIteration(value) {
                this.useStrictIteration_ = value;
            }
        },
        {
            key: "shouldUseStrictIteration",
            value: function shouldUseStrictIteration() {
                return this.useStrictIteration_;
            }
        },
        {
            key: "applyPatches",
            value: function applyPatches(base, patches) {
                var i;
                for(i = patches.length - 1; i >= 0; i--){
                    var patch = patches[i];
                    if (patch.path.length === 0 && patch.op === "replace") {
                        base = patch.value;
                        break;
                    }
                }
                if (i > -1) {
                    patches = patches.slice(i + 1);
                }
                var applyPatchesImpl = getPlugin("Patches").applyPatches_;
                if (isDraft(base)) {
                    return applyPatchesImpl(base, patches);
                }
                return this.produce(base, function(draft) {
                    return applyPatchesImpl(draft, patches);
                });
            }
        }
    ]);
    return Immer2;
}();
function createProxy(value, parent) {
    var draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
    var scope = parent ? parent.scope_ : getCurrentScope();
    scope.drafts_.push(draft);
    return draft;
}
// src/core/current.ts
function current(value) {
    if (!isDraft(value)) die(10, value);
    return currentImpl(value);
}
function currentImpl(value) {
    if (!isDraftable(value) || isFrozen(value)) return value;
    var state = value[DRAFT_STATE];
    var copy;
    var strict = true;
    if (state) {
        if (!state.modified_) return state.base_;
        state.finalized_ = true;
        copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
        strict = state.scope_.immer_.shouldUseStrictIteration();
    } else {
        copy = shallowCopy(value, true);
    }
    each(copy, function(key, childValue) {
        set(copy, key, currentImpl(childValue));
    }, strict);
    if (state) {
        state.finalized_ = false;
    }
    return copy;
}
// src/plugins/patches.ts
function enablePatches() {
    var errorOffset = 16;
    if ("TURBOPACK compile-time truthy", 1) {
        errors.push('Sets cannot have "replace" patches.', function(op) {
            return "Unsupported patch operation: " + op;
        }, function(path) {
            return "Cannot apply patch, path doesn't resolve: " + path;
        }, "Patching reserved attributes like __proto__, prototype and constructor is not allowed");
    }
    var REPLACE = "replace";
    var ADD = "add";
    var REMOVE = "remove";
    function generatePatches_(state, basePath, patches, inversePatches) {
        switch(state.type_){
            case 0 /* Object */ :
            case 2 /* Map */ :
                return generatePatchesFromAssigned(state, basePath, patches, inversePatches);
            case 1 /* Array */ :
                return generateArrayPatches(state, basePath, patches, inversePatches);
            case 3 /* Set */ :
                return generateSetPatches(state, basePath, patches, inversePatches);
        }
    }
    function generateArrayPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, assigned_ = state.assigned_;
        var copy_ = state.copy_;
        if (copy_.length < base_.length) {
            ;
            var ref;
            ref = [
                copy_,
                base_
            ], base_ = ref[0], copy_ = ref[1], ref;
            var ref1;
            ref1 = [
                inversePatches,
                patches
            ], patches = ref1[0], inversePatches = ref1[1], ref1;
        }
        for(var i = 0; i < base_.length; i++){
            if (assigned_[i] && copy_[i] !== base_[i]) {
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REPLACE,
                    path: path,
                    // Need to maybe clone it, as it can in fact be the original value
                    // due to the base/copy inversion at the start of this function
                    value: clonePatchValueIfNeeded(copy_[i])
                });
                inversePatches.push({
                    op: REPLACE,
                    path: path,
                    value: clonePatchValueIfNeeded(base_[i])
                });
            }
        }
        for(var i1 = base_.length; i1 < copy_.length; i1++){
            var path1 = basePath.concat([
                i1
            ]);
            patches.push({
                op: ADD,
                path: path1,
                // Need to maybe clone it, as it can in fact be the original value
                // due to the base/copy inversion at the start of this function
                value: clonePatchValueIfNeeded(copy_[i1])
            });
        }
        for(var i2 = copy_.length - 1; base_.length <= i2; --i2){
            var path2 = basePath.concat([
                i2
            ]);
            inversePatches.push({
                op: REMOVE,
                path: path2
            });
        }
    }
    function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        each(state.assigned_, function(key, assignedValue) {
            var origValue = get(base_, key);
            var value = get(copy_, key);
            var op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;
            if (origValue === value && op === REPLACE) return;
            var path = basePath.concat(key);
            patches.push(op === REMOVE ? {
                op: op,
                path: path
            } : {
                op: op,
                path: path,
                value: value
            });
            inversePatches.push(op === ADD ? {
                op: REMOVE,
                path: path
            } : op === REMOVE ? {
                op: ADD,
                path: path,
                value: clonePatchValueIfNeeded(origValue)
            } : {
                op: REPLACE,
                path: path,
                value: clonePatchValueIfNeeded(origValue)
            });
        });
    }
    function generateSetPatches(state, basePath, patches, inversePatches) {
        var base_ = state.base_, copy_ = state.copy_;
        var i = 0;
        base_.forEach(function(value) {
            if (!copy_.has(value)) {
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: REMOVE,
                    path: path,
                    value: value
                });
                inversePatches.unshift({
                    op: ADD,
                    path: path,
                    value: value
                });
            }
            i++;
        });
        i = 0;
        copy_.forEach(function(value) {
            if (!base_.has(value)) {
                var path = basePath.concat([
                    i
                ]);
                patches.push({
                    op: ADD,
                    path: path,
                    value: value
                });
                inversePatches.unshift({
                    op: REMOVE,
                    path: path,
                    value: value
                });
            }
            i++;
        });
    }
    function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {
        patches.push({
            op: REPLACE,
            path: [],
            value: replacement === NOTHING ? void 0 : replacement
        });
        inversePatches.push({
            op: REPLACE,
            path: [],
            value: baseValue
        });
    }
    function applyPatches_(draft, patches) {
        patches.forEach(function(patch) {
            var path = patch.path, op = patch.op;
            var base = draft;
            for(var i = 0; i < path.length - 1; i++){
                var parentType = getArchtype(base);
                var p = path[i];
                if (typeof p !== "string" && typeof p !== "number") {
                    p = "" + p;
                }
                if ((parentType === 0 /* Object */  || parentType === 1 /* Array */ ) && (p === "__proto__" || p === "constructor")) die(errorOffset + 3);
                if (typeof base === "function" && p === "prototype") die(errorOffset + 3);
                base = get(base, p);
                if ((typeof base === "undefined" ? "undefined" : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_type_of$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(base)) !== "object") die(errorOffset + 2, path.join("/"));
            }
            var type = getArchtype(base);
            var value = deepClonePatchValue(patch.value);
            var key = path[path.length - 1];
            switch(op){
                case REPLACE:
                    switch(type){
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            die(errorOffset);
                        default:
                            return base[key] = value;
                    }
                case ADD:
                    switch(type){
                        case 1 /* Array */ :
                            return key === "-" ? base.push(value) : base.splice(key, 0, value);
                        case 2 /* Map */ :
                            return base.set(key, value);
                        case 3 /* Set */ :
                            return base.add(value);
                        default:
                            return base[key] = value;
                    }
                case REMOVE:
                    switch(type){
                        case 1 /* Array */ :
                            return base.splice(key, 1);
                        case 2 /* Map */ :
                            return base["delete"](key);
                        case 3 /* Set */ :
                            return base["delete"](patch.value);
                        default:
                            return delete base[key];
                    }
                default:
                    die(errorOffset + 1, op);
            }
        });
        return draft;
    }
    function deepClonePatchValue(obj) {
        if (!isDraftable(obj)) return obj;
        if (Array.isArray(obj)) return obj.map(deepClonePatchValue);
        if (isMap(obj)) return new Map(Array.from(obj.entries()).map(function(param) {
            var _param = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_sliced_to_array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(param, 2), k = _param[0], v = _param[1];
            return [
                k,
                deepClonePatchValue(v)
            ];
        }));
        if (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue));
        var cloned = Object.create(getPrototypeOf(obj));
        for(var key in obj)cloned[key] = deepClonePatchValue(obj[key]);
        if (has(obj, DRAFTABLE)) cloned[DRAFTABLE] = obj[DRAFTABLE];
        return cloned;
    }
    function clonePatchValueIfNeeded(obj) {
        if (isDraft(obj)) {
            return deepClonePatchValue(obj);
        } else return obj;
    }
    loadPlugin("Patches", {
        applyPatches_: applyPatches_,
        generatePatches_: generatePatches_,
        generateReplacementPatches_: generateReplacementPatches_
    });
}
// src/plugins/mapset.ts
function enableMapSet() {
    var DraftMap = /*#__PURE__*/ function(Map1) {
        "use strict";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftMap, Map1);
        function DraftMap(target, parent) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftMap);
            var _this;
            _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftMap);
            _this[DRAFT_STATE] = {
                type_: 2 /* Map */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                assigned_: void 0,
                base_: target,
                draft_: _this,
                isManual_: false,
                revoked_: false
            };
            return _this;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftMap, [
            {
                key: "size",
                get: function get() {
                    return latest(this[DRAFT_STATE]).size;
                }
            },
            {
                key: "has",
                value: function has(key) {
                    return latest(this[DRAFT_STATE]).has(key);
                }
            },
            {
                key: "set",
                value: function set(key, value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!latest(state).has(key) || latest(state).get(key) !== value) {
                        prepareMapCopy(state);
                        markChanged(state);
                        state.assigned_.set(key, true);
                        state.copy_.set(key, value);
                        state.assigned_.set(key, true);
                    }
                    return this;
                }
            },
            {
                key: "delete",
                value: function _delete(key) {
                    if (!this.has(key)) {
                        return false;
                    }
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareMapCopy(state);
                    markChanged(state);
                    if (state.base_.has(key)) {
                        state.assigned_.set(key, false);
                    } else {
                        state.assigned_["delete"](key);
                    }
                    state.copy_["delete"](key);
                    return true;
                }
            },
            {
                key: "clear",
                value: function clear() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (latest(state).size) {
                        prepareMapCopy(state);
                        markChanged(state);
                        state.assigned_ = /* @__PURE__ */ new Map();
                        each(state.base_, function(key) {
                            state.assigned_.set(key, false);
                        });
                        state.copy_.clear();
                    }
                }
            },
            {
                key: "forEach",
                value: function forEach(cb, thisArg) {
                    var _this = this;
                    var state = this[DRAFT_STATE];
                    latest(state).forEach(function(_value, key, _map) {
                        cb.call(thisArg, _this.get(key), key, _this);
                    });
                }
            },
            {
                key: "get",
                value: function get(key) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    var value = latest(state).get(key);
                    if (state.finalized_ || !isDraftable(value)) {
                        return value;
                    }
                    if (value !== state.base_.get(key)) {
                        return value;
                    }
                    var draft = createProxy(value, state);
                    prepareMapCopy(state);
                    state.copy_.set(key, draft);
                    return draft;
                }
            },
            {
                key: "keys",
                value: function keys() {
                    return latest(this[DRAFT_STATE]).keys();
                }
            },
            {
                key: "values",
                value: function values() {
                    var _this = this;
                    var iterator = this.keys();
                    var _obj;
                    return _obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, Symbol.iterator, function() {
                        return _this.values();
                    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, "next", function() {
                        var r = iterator.next();
                        if (r.done) return r;
                        var value = _this.get(r.value);
                        return {
                            done: false,
                            value: value
                        };
                    }), _obj;
                }
            },
            {
                key: "entries",
                value: function entries() {
                    var _this = this;
                    var iterator = this.keys();
                    var _obj;
                    return _obj = {}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, Symbol.iterator, function() {
                        return _this.entries();
                    }), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_define_property$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(_obj, "next", function() {
                        var r = iterator.next();
                        if (r.done) return r;
                        var value = _this.get(r.value);
                        return {
                            done: false,
                            value: [
                                r.value,
                                value
                            ]
                        };
                    }), _obj;
                }
            },
            {
                key: (DRAFT_STATE, Symbol.iterator),
                value: function value() {
                    return this.entries();
                }
            }
        ]);
        return DraftMap;
    }((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Map));
    function proxyMap_(target, parent) {
        return new DraftMap(target, parent);
    }
    function prepareMapCopy(state) {
        if (!state.copy_) {
            state.assigned_ = /* @__PURE__ */ new Map();
            state.copy_ = new Map(state.base_);
        }
    }
    var DraftSet = /*#__PURE__*/ function(Set1) {
        "use strict";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_inherits$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftSet, Set1);
        function DraftSet(target, parent) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_class_call_check$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftSet);
            var _this;
            _this = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_call_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(this, DraftSet);
            _this[DRAFT_STATE] = {
                type_: 3 /* Set */ ,
                parent_: parent,
                scope_: parent ? parent.scope_ : getCurrentScope(),
                modified_: false,
                finalized_: false,
                copy_: void 0,
                base_: target,
                draft_: _this,
                drafts_: /* @__PURE__ */ new Map(),
                revoked_: false,
                isManual_: false
            };
            return _this;
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_create_class$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(DraftSet, [
            {
                key: "size",
                get: function get() {
                    return latest(this[DRAFT_STATE]).size;
                }
            },
            {
                key: "has",
                value: function has(value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!state.copy_) {
                        return state.base_.has(value);
                    }
                    if (state.copy_.has(value)) return true;
                    if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value))) return true;
                    return false;
                }
            },
            {
                key: "add",
                value: function add(value) {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (!this.has(value)) {
                        prepareSetCopy(state);
                        markChanged(state);
                        state.copy_.add(value);
                    }
                    return this;
                }
            },
            {
                key: "delete",
                value: function _delete(value) {
                    if (!this.has(value)) {
                        return false;
                    }
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    markChanged(state);
                    return state.copy_["delete"](value) || (state.drafts_.has(value) ? state.copy_["delete"](state.drafts_.get(value)) : /* istanbul ignore next */ false);
                }
            },
            {
                key: "clear",
                value: function clear() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    if (latest(state).size) {
                        prepareSetCopy(state);
                        markChanged(state);
                        state.copy_.clear();
                    }
                }
            },
            {
                key: "values",
                value: function values() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    return state.copy_.values();
                }
            },
            {
                key: "entries",
                value: function entries() {
                    var state = this[DRAFT_STATE];
                    assertUnrevoked(state);
                    prepareSetCopy(state);
                    return state.copy_.entries();
                }
            },
            {
                key: "keys",
                value: function keys() {
                    return this.values();
                }
            },
            {
                key: (DRAFT_STATE, Symbol.iterator),
                value: function value() {
                    return this.values();
                }
            },
            {
                key: "forEach",
                value: function forEach(cb, thisArg) {
                    var iterator = this.values();
                    var result = iterator.next();
                    while(!result.done){
                        cb.call(thisArg, result.value, result.value, this);
                        result = iterator.next();
                    }
                }
            }
        ]);
        return DraftSet;
    }((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$swc$2f$helpers$2f$esm$2f$_wrap_native_super$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["_"])(Set));
    function proxySet_(target, parent) {
        return new DraftSet(target, parent);
    }
    function prepareSetCopy(state) {
        if (!state.copy_) {
            state.copy_ = /* @__PURE__ */ new Set();
            state.base_.forEach(function(value) {
                if (isDraftable(value)) {
                    var draft = createProxy(value, state);
                    state.drafts_.set(value, draft);
                    state.copy_.add(draft);
                } else {
                    state.copy_.add(value);
                }
            });
        }
    }
    function assertUnrevoked(state) {
        if (state.revoked_) die(3, JSON.stringify(latest(state)));
    }
    loadPlugin("MapSet", {
        proxyMap_: proxyMap_,
        proxySet_: proxySet_
    });
}
// src/immer.ts
var immer = new Immer2();
var produce = immer.produce;
var produceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(immer);
var setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer);
var setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(immer);
var setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(immer);
var applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer);
var createDraft = /* @__PURE__ */ immer.createDraft.bind(immer);
var finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer);
function castDraft(value) {
    return value;
}
function castImmutable(value) {
    return value;
}
;
 //# sourceMappingURL=immer.mjs.map
}),
]);

//# sourceMappingURL=node_modules_bdb084c3._.js.map